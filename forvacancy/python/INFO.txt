1 Задание:
вверхний пример из теста, нижний мой пример.
Вывод: если сравнивать две функции то они идентичны по своей функциональности,
единственное что, я использовал "not" и битовые операции для своей функции, что может как-то
повлиять на скорость работы самой программы, так как битовая опервция намного быстрее, чем
встроенная операция деления, нужно будет проверить с помощью ассемблера на Clang или MSVC.



2 Задание:
Если рассмотреть различия каждого из варианта, то для списковой реализации необходимо дополнительно
4 байта на указатель (8 на 64 битных системах). Это минус данной реализации.
Если рассматривать реализацию под микроскопом, то в 1 варианте, у нас присваивание и обращение к свойству структуры.
Во втором варианте — префиксный инкремент + сравнение, в итоге получаем 2 операции.
Таким образом можно сказать, что вариант с списком более быстрый, а вариант с массивом занимает меньше места, как-то так ¯\_(ツ)_/¯

3 Задание:
Выбрать один единственный метод из того множества сортировок, которые у нас есть невозможно. Каждый метод имеет свои
плюсы и минусы. Если вспомнить первую приходящую на ум эффективную сортировку, а то есть быструю сортировку,
то с ней не все так гладко она может уходить в n^2 в худшем случае. Также она имеет проблему с тем что она не стабильная,
что может повлиять на скорость если сортируются комплексные объекты. Также у нее проблема, если мы сортируем связный список,
а не массив. Например, сортировке слиянием в тоже время без разницы, список это или массив. Также плюсом этой сортировки является гарантированное
n*logn время, а также возможность ее распараллеливания, например, в отличии от сортировкой кучей, которая также имеет потолок в n*logn.
Но тут стоит вспомнить, что сортировка слиянием требует n памяти, в отличии от быстрой (память для рекурсии logn) и кучей (1).
На маленьком количестве данных (около 20) не стоит забывать и о простых методах сортировки (вставками, выбора),
так как на таком количестве n^2 не сильно отличается от n*logn. Конечно, надо также вспомнить и о такой сортировке,
как Timsort, которая является сортировкой по-умолчанию в Python. Эта сортировка ведет себя почти на уровне быстрой,
но, в тоже время, на частично упорядоченных массивах показывает неплохой прирост. Конечно, существует еще множество сортировок, но я хотел лишь привести к тому,
что нельзя без информации о данных привести наилучший результат. Именно поэтому я не смогу привести пример который бы угодил в условие задания,
но вполне cмогу привести хоть какой-нибудь пример, со своими входными данными.